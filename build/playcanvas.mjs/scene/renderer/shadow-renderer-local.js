import { DebugHelper } from '../../core/debug.js';
import { math } from '../../core/math/math.js';
import { ShadowMap } from './shadow-map.js';
import { LIGHTTYPE_SPOT, LIGHTTYPE_OMNI } from '../constants.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';

/**
 * @ignore
 */
class ShadowRendererLocal {
  constructor(renderer, shadowRenderer) {
    // temporary list to collect lights to render shadows for
    this.shadowLights = [];
    /** @type {import('./renderer.js').Renderer} */
    this.renderer = void 0;
    /** @type {import('./shadow-renderer.js').ShadowRenderer} */
    this.shadowRenderer = void 0;
    /** @type {import('../../platform/graphics/graphics-device.js').GraphicsDevice} */
    this.device = void 0;
    this.renderer = renderer;
    this.shadowRenderer = shadowRenderer;
    this.device = renderer.device;
  }

  // cull local shadow map
  cull(light, comp, casters = null) {
    const isClustered = this.renderer.scene.clusteredLightingEnabled;

    // force light visibility if function was manually called
    light.visibleThisFrame = true;

    // allocate shadow map unless in clustered lighting mode
    if (!isClustered) {
      if (!light._shadowMap) {
        light._shadowMap = ShadowMap.create(this.device, light);
      }
    }
    const type = light._type;
    const faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;
    for (let face = 0; face < faceCount; face++) {
      // render data are shared between cameras for local lights, so pass null for camera
      const lightRenderData = light.getRenderData(null, face);
      const shadowCam = lightRenderData.shadowCamera;
      shadowCam.nearClip = light.attenuationEnd / 1000;
      shadowCam.farClip = light.attenuationEnd;
      lightRenderData.depthRangeCompensation = shadowCam.farClip - shadowCam.nearClip;
      const shadowCamNode = shadowCam._node;
      const lightNode = light._node;
      shadowCamNode.setPosition(lightNode.getPosition());
      if (type === LIGHTTYPE_SPOT) {
        shadowCam.fov = light._outerConeAngle * 2;

        // Camera looks down the negative Z, and spot light points down the negative Y
        shadowCamNode.setRotation(lightNode.getRotation());
        shadowCamNode.rotateLocal(-90, 0, 0);
      } else if (type === LIGHTTYPE_OMNI) {
        // when rendering omni shadows to an atlas, use larger fov by few pixels to allow shadow filtering to stay on a single face
        if (isClustered) {
          const tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3; // using 3x3 for cubemap
          const texelSize = 2 / tileSize;
          const filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
          shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
        } else {
          shadowCam.fov = 90;
        }
      }

      // cull shadow casters
      this.renderer.updateCameraFrustum(shadowCam);
      this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
    }
  }
  prepareLights(shadowLights, lights) {
    let shadowCamera;
    for (let i = 0; i < lights.length; i++) {
      const light = lights[i];
      if (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {
        shadowLights.push(light);
        for (let face = 0; face < light.numShadowFaces; face++) {
          shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
        }
      }
    }
    return shadowCamera;
  }

  /**
   * Prepare render pass for rendering of shadows for local clustered lights. This is done inside
   * a single render pass, as all shadows are part of a single render target atlas.
   */
  prepareClusteredRenderPass(renderPass, localLights) {
    // prepare render targets / shadow cameras for rendering
    const shadowLights = this.shadowLights;
    const shadowCamera = this.prepareLights(shadowLights, localLights);

    // if any shadows need to be rendered
    const count = shadowLights.length;
    if (count) {
      // setup render pass using any of the cameras, they all have the same pass related properties
      // Note that the render pass is set up to not clear the render target, as individual shadow maps clear it
      this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, false);

      // render shadows inside the pass
      renderPass._execute = () => {
        for (let i = 0; i < count; i++) {
          const light = shadowLights[i];
          for (let face = 0; face < light.numShadowFaces; face++) {
            this.shadowRenderer.renderFace(light, null, face, true);
          }
        }
        shadowLights.length = 0;
      };
    }
  }
  setupNonClusteredFaceRenderPass(frameGraph, light, face, applyVsm) {
    const shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
    const renderPass = new RenderPass(this.device, () => {
      this.shadowRenderer.renderFace(light, null, face, false);
    });

    // clear the render target as well, as it contains a single shadow map
    this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, true);
    DebugHelper.setName(renderPass, `SpotShadow-${light._node.name}`);

    // apply vsm
    if (applyVsm) {
      renderPass._after = () => {
        // after the pass is done, apply VSM blur if needed
        this.shadowRenderer.renderVsm(light, shadowCamera);
      };
    }
    frameGraph.addRenderPass(renderPass);
  }

  /**
   * Prepare render passes for rendering of shadows for local non-clustered lights. Each shadow face
   * is a separate render pass as it renders to a separate render target.
   */
  buildNonClusteredRenderPasses(frameGraph, localLights) {
    for (let i = 0; i < localLights.length; i++) {
      const light = localLights[i];
      if (this.shadowRenderer.needsShadowRendering(light)) {
        // only spot lights support VSM
        const applyVsm = light._type === LIGHTTYPE_SPOT;

        // create render pass per face
        const faceCount = light.numShadowFaces;
        for (let face = 0; face < faceCount; face++) {
          this.setupNonClusteredFaceRenderPass(frameGraph, light, face, applyVsm);
        }
      }
    }
  }
}

export { ShadowRendererLocal };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZG93LXJlbmRlcmVyLWxvY2FsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2NlbmUvcmVuZGVyZXIvc2hhZG93LXJlbmRlcmVyLWxvY2FsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlYnVnSGVscGVyIH0gZnJvbSAnLi4vLi4vY29yZS9kZWJ1Zy5qcyc7XG5pbXBvcnQgeyBtYXRoIH0gZnJvbSAnLi4vLi4vY29yZS9tYXRoL21hdGguanMnO1xuXG5pbXBvcnQgeyBTaGFkb3dNYXAgfSBmcm9tICcuL3NoYWRvdy1tYXAuanMnO1xuaW1wb3J0IHtcbiAgICBMSUdIVFRZUEVfT01OSSwgTElHSFRUWVBFX1NQT1Rcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcblxuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3JlbmRlci1wYXNzLmpzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIFNoYWRvd1JlbmRlcmVyTG9jYWwge1xuICAgIC8vIHRlbXBvcmFyeSBsaXN0IHRvIGNvbGxlY3QgbGlnaHRzIHRvIHJlbmRlciBzaGFkb3dzIGZvclxuICAgIHNoYWRvd0xpZ2h0cyA9IFtdO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vcmVuZGVyZXIuanMnKS5SZW5kZXJlcn0gKi9cbiAgICByZW5kZXJlcjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3NoYWRvdy1yZW5kZXJlci5qcycpLlNoYWRvd1JlbmRlcmVyfSAqL1xuICAgIHNoYWRvd1JlbmRlcmVyO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL2dyYXBoaWNzLWRldmljZS5qcycpLkdyYXBoaWNzRGV2aWNlfSAqL1xuICAgIGRldmljZTtcblxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBzaGFkb3dSZW5kZXJlcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuc2hhZG93UmVuZGVyZXIgPSBzaGFkb3dSZW5kZXJlcjtcbiAgICAgICAgdGhpcy5kZXZpY2UgPSByZW5kZXJlci5kZXZpY2U7XG4gICAgfVxuXG4gICAgLy8gY3VsbCBsb2NhbCBzaGFkb3cgbWFwXG4gICAgY3VsbChsaWdodCwgY29tcCwgY2FzdGVycyA9IG51bGwpIHtcblxuICAgICAgICBjb25zdCBpc0NsdXN0ZXJlZCA9IHRoaXMucmVuZGVyZXIuc2NlbmUuY2x1c3RlcmVkTGlnaHRpbmdFbmFibGVkO1xuXG4gICAgICAgIC8vIGZvcmNlIGxpZ2h0IHZpc2liaWxpdHkgaWYgZnVuY3Rpb24gd2FzIG1hbnVhbGx5IGNhbGxlZFxuICAgICAgICBsaWdodC52aXNpYmxlVGhpc0ZyYW1lID0gdHJ1ZTtcblxuICAgICAgICAvLyBhbGxvY2F0ZSBzaGFkb3cgbWFwIHVubGVzcyBpbiBjbHVzdGVyZWQgbGlnaHRpbmcgbW9kZVxuICAgICAgICBpZiAoIWlzQ2x1c3RlcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWxpZ2h0Ll9zaGFkb3dNYXApIHtcbiAgICAgICAgICAgICAgICBsaWdodC5fc2hhZG93TWFwID0gU2hhZG93TWFwLmNyZWF0ZSh0aGlzLmRldmljZSwgbGlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IGxpZ2h0Ll90eXBlO1xuICAgICAgICBjb25zdCBmYWNlQ291bnQgPSB0eXBlID09PSBMSUdIVFRZUEVfU1BPVCA/IDEgOiA2O1xuXG4gICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgZmFjZUNvdW50OyBmYWNlKyspIHtcblxuICAgICAgICAgICAgLy8gcmVuZGVyIGRhdGEgYXJlIHNoYXJlZCBiZXR3ZWVuIGNhbWVyYXMgZm9yIGxvY2FsIGxpZ2h0cywgc28gcGFzcyBudWxsIGZvciBjYW1lcmFcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0UmVuZGVyRGF0YSA9IGxpZ2h0LmdldFJlbmRlckRhdGEobnVsbCwgZmFjZSk7XG4gICAgICAgICAgICBjb25zdCBzaGFkb3dDYW0gPSBsaWdodFJlbmRlckRhdGEuc2hhZG93Q2FtZXJhO1xuXG4gICAgICAgICAgICBzaGFkb3dDYW0ubmVhckNsaXAgPSBsaWdodC5hdHRlbnVhdGlvbkVuZCAvIDEwMDA7XG4gICAgICAgICAgICBzaGFkb3dDYW0uZmFyQ2xpcCA9IGxpZ2h0LmF0dGVudWF0aW9uRW5kO1xuXG4gICAgICAgICAgICBsaWdodFJlbmRlckRhdGEuZGVwdGhSYW5nZUNvbXBlbnNhdGlvbiA9IHNoYWRvd0NhbS5mYXJDbGlwIC0gc2hhZG93Q2FtLm5lYXJDbGlwO1xuXG4gICAgICAgICAgICBjb25zdCBzaGFkb3dDYW1Ob2RlID0gc2hhZG93Q2FtLl9ub2RlO1xuICAgICAgICAgICAgY29uc3QgbGlnaHROb2RlID0gbGlnaHQuX25vZGU7XG4gICAgICAgICAgICBzaGFkb3dDYW1Ob2RlLnNldFBvc2l0aW9uKGxpZ2h0Tm9kZS5nZXRQb3NpdGlvbigpKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IExJR0hUVFlQRV9TUE9UKSB7XG4gICAgICAgICAgICAgICAgc2hhZG93Q2FtLmZvdiA9IGxpZ2h0Ll9vdXRlckNvbmVBbmdsZSAqIDI7XG5cbiAgICAgICAgICAgICAgICAvLyBDYW1lcmEgbG9va3MgZG93biB0aGUgbmVnYXRpdmUgWiwgYW5kIHNwb3QgbGlnaHQgcG9pbnRzIGRvd24gdGhlIG5lZ2F0aXZlIFlcbiAgICAgICAgICAgICAgICBzaGFkb3dDYW1Ob2RlLnNldFJvdGF0aW9uKGxpZ2h0Tm9kZS5nZXRSb3RhdGlvbigpKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dDYW1Ob2RlLnJvdGF0ZUxvY2FsKC05MCwgMCwgMCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTElHSFRUWVBFX09NTkkpIHtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIG9tbmkgc2hhZG93cyB0byBhbiBhdGxhcywgdXNlIGxhcmdlciBmb3YgYnkgZmV3IHBpeGVscyB0byBhbGxvdyBzaGFkb3cgZmlsdGVyaW5nIHRvIHN0YXkgb24gYSBzaW5nbGUgZmFjZVxuICAgICAgICAgICAgICAgIGlmIChpc0NsdXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlU2l6ZSA9IHRoaXMuc2hhZG93UmVuZGVyZXIubGlnaHRUZXh0dXJlQXRsYXMuc2hhZG93QXRsYXNSZXNvbHV0aW9uICogbGlnaHQuYXRsYXNWaWV3cG9ydC56IC8gMzsgICAgLy8gdXNpbmcgM3gzIGZvciBjdWJlbWFwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleGVsU2l6ZSA9IDIgLyB0aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyU2l6ZSA9IHRleGVsU2l6ZSAqIHRoaXMuc2hhZG93UmVuZGVyZXIubGlnaHRUZXh0dXJlQXRsYXMuc2hhZG93RWRnZVBpeGVscztcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93Q2FtLmZvdiA9IE1hdGguYXRhbigxICsgZmlsdGVyU2l6ZSkgKiBtYXRoLlJBRF9UT19ERUcgKiAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0NhbS5mb3YgPSA5MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGN1bGwgc2hhZG93IGNhc3RlcnNcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ2FtZXJhRnJ1c3R1bShzaGFkb3dDYW0pO1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5jdWxsU2hhZG93Q2FzdGVycyhjb21wLCBsaWdodCwgbGlnaHRSZW5kZXJEYXRhLnZpc2libGVDYXN0ZXJzLCBzaGFkb3dDYW0sIGNhc3RlcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJlcGFyZUxpZ2h0cyhzaGFkb3dMaWdodHMsIGxpZ2h0cykge1xuXG4gICAgICAgIGxldCBzaGFkb3dDYW1lcmE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaWdodCA9IGxpZ2h0c1tpXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93UmVuZGVyZXIubmVlZHNTaGFkb3dSZW5kZXJpbmcobGlnaHQpICYmIGxpZ2h0LmF0bGFzVmlld3BvcnRBbGxvY2F0ZWQpIHtcblxuICAgICAgICAgICAgICAgIHNoYWRvd0xpZ2h0cy5wdXNoKGxpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgbGlnaHQubnVtU2hhZG93RmFjZXM7IGZhY2UrKykge1xuICAgICAgICAgICAgICAgICAgICBzaGFkb3dDYW1lcmEgPSB0aGlzLnNoYWRvd1JlbmRlcmVyLnByZXBhcmVGYWNlKGxpZ2h0LCBudWxsLCBmYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhZG93Q2FtZXJhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgcmVuZGVyIHBhc3MgZm9yIHJlbmRlcmluZyBvZiBzaGFkb3dzIGZvciBsb2NhbCBjbHVzdGVyZWQgbGlnaHRzLiBUaGlzIGlzIGRvbmUgaW5zaWRlXG4gICAgICogYSBzaW5nbGUgcmVuZGVyIHBhc3MsIGFzIGFsbCBzaGFkb3dzIGFyZSBwYXJ0IG9mIGEgc2luZ2xlIHJlbmRlciB0YXJnZXQgYXRsYXMuXG4gICAgICovXG4gICAgcHJlcGFyZUNsdXN0ZXJlZFJlbmRlclBhc3MocmVuZGVyUGFzcywgbG9jYWxMaWdodHMpIHtcblxuICAgICAgICAvLyBwcmVwYXJlIHJlbmRlciB0YXJnZXRzIC8gc2hhZG93IGNhbWVyYXMgZm9yIHJlbmRlcmluZ1xuICAgICAgICBjb25zdCBzaGFkb3dMaWdodHMgPSB0aGlzLnNoYWRvd0xpZ2h0cztcbiAgICAgICAgY29uc3Qgc2hhZG93Q2FtZXJhID0gdGhpcy5wcmVwYXJlTGlnaHRzKHNoYWRvd0xpZ2h0cywgbG9jYWxMaWdodHMpO1xuXG4gICAgICAgIC8vIGlmIGFueSBzaGFkb3dzIG5lZWQgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgY29uc3QgY291bnQgPSBzaGFkb3dMaWdodHMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQpIHtcblxuICAgICAgICAgICAgLy8gc2V0dXAgcmVuZGVyIHBhc3MgdXNpbmcgYW55IG9mIHRoZSBjYW1lcmFzLCB0aGV5IGFsbCBoYXZlIHRoZSBzYW1lIHBhc3MgcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHJlbmRlciBwYXNzIGlzIHNldCB1cCB0byBub3QgY2xlYXIgdGhlIHJlbmRlciB0YXJnZXQsIGFzIGluZGl2aWR1YWwgc2hhZG93IG1hcHMgY2xlYXIgaXRcbiAgICAgICAgICAgIHRoaXMuc2hhZG93UmVuZGVyZXIuc2V0dXBSZW5kZXJQYXNzKHJlbmRlclBhc3MsIHNoYWRvd0NhbWVyYSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyByZW5kZXIgc2hhZG93cyBpbnNpZGUgdGhlIHBhc3NcbiAgICAgICAgICAgIHJlbmRlclBhc3MuX2V4ZWN1dGUgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlnaHQgPSBzaGFkb3dMaWdodHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGZhY2UgPSAwOyBmYWNlIDwgbGlnaHQubnVtU2hhZG93RmFjZXM7IGZhY2UrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5yZW5kZXJGYWNlKGxpZ2h0LCBudWxsLCBmYWNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNoYWRvd0xpZ2h0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldHVwTm9uQ2x1c3RlcmVkRmFjZVJlbmRlclBhc3MoZnJhbWVHcmFwaCwgbGlnaHQsIGZhY2UsIGFwcGx5VnNtKSB7XG5cbiAgICAgICAgY29uc3Qgc2hhZG93Q2FtZXJhID0gdGhpcy5zaGFkb3dSZW5kZXJlci5wcmVwYXJlRmFjZShsaWdodCwgbnVsbCwgZmFjZSk7XG4gICAgICAgIGNvbnN0IHJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyh0aGlzLmRldmljZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5yZW5kZXJGYWNlKGxpZ2h0LCBudWxsLCBmYWNlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSByZW5kZXIgdGFyZ2V0IGFzIHdlbGwsIGFzIGl0IGNvbnRhaW5zIGEgc2luZ2xlIHNoYWRvdyBtYXBcbiAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5zZXR1cFJlbmRlclBhc3MocmVuZGVyUGFzcywgc2hhZG93Q2FtZXJhLCB0cnVlKTtcbiAgICAgICAgRGVidWdIZWxwZXIuc2V0TmFtZShyZW5kZXJQYXNzLCBgU3BvdFNoYWRvdy0ke2xpZ2h0Ll9ub2RlLm5hbWV9YCk7XG5cbiAgICAgICAgLy8gYXBwbHkgdnNtXG4gICAgICAgIGlmIChhcHBseVZzbSkge1xuICAgICAgICAgICAgcmVuZGVyUGFzcy5fYWZ0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHBhc3MgaXMgZG9uZSwgYXBwbHkgVlNNIGJsdXIgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSZW5kZXJlci5yZW5kZXJWc20obGlnaHQsIHNoYWRvd0NhbWVyYSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhbWVHcmFwaC5hZGRSZW5kZXJQYXNzKHJlbmRlclBhc3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgcmVuZGVyIHBhc3NlcyBmb3IgcmVuZGVyaW5nIG9mIHNoYWRvd3MgZm9yIGxvY2FsIG5vbi1jbHVzdGVyZWQgbGlnaHRzLiBFYWNoIHNoYWRvdyBmYWNlXG4gICAgICogaXMgYSBzZXBhcmF0ZSByZW5kZXIgcGFzcyBhcyBpdCByZW5kZXJzIHRvIGEgc2VwYXJhdGUgcmVuZGVyIHRhcmdldC5cbiAgICAgKi9cbiAgICBidWlsZE5vbkNsdXN0ZXJlZFJlbmRlclBhc3NlcyhmcmFtZUdyYXBoLCBsb2NhbExpZ2h0cykge1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxMaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gbG9jYWxMaWdodHNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1JlbmRlcmVyLm5lZWRzU2hhZG93UmVuZGVyaW5nKGxpZ2h0KSkge1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSBzcG90IGxpZ2h0cyBzdXBwb3J0IFZTTVxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcGx5VnNtID0gbGlnaHQuX3R5cGUgPT09IExJR0hUVFlQRV9TUE9UO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHJlbmRlciBwYXNzIHBlciBmYWNlXG4gICAgICAgICAgICAgICAgY29uc3QgZmFjZUNvdW50ID0gbGlnaHQubnVtU2hhZG93RmFjZXM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCBmYWNlQ291bnQ7IGZhY2UrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwTm9uQ2x1c3RlcmVkRmFjZVJlbmRlclBhc3MoZnJhbWVHcmFwaCwgbGlnaHQsIGZhY2UsIGFwcGx5VnNtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFNoYWRvd1JlbmRlcmVyTG9jYWwgfTtcbiJdLCJuYW1lcyI6WyJTaGFkb3dSZW5kZXJlckxvY2FsIiwiY29uc3RydWN0b3IiLCJyZW5kZXJlciIsInNoYWRvd1JlbmRlcmVyIiwic2hhZG93TGlnaHRzIiwiZGV2aWNlIiwiY3VsbCIsImxpZ2h0IiwiY29tcCIsImNhc3RlcnMiLCJpc0NsdXN0ZXJlZCIsInNjZW5lIiwiY2x1c3RlcmVkTGlnaHRpbmdFbmFibGVkIiwidmlzaWJsZVRoaXNGcmFtZSIsIl9zaGFkb3dNYXAiLCJTaGFkb3dNYXAiLCJjcmVhdGUiLCJ0eXBlIiwiX3R5cGUiLCJmYWNlQ291bnQiLCJMSUdIVFRZUEVfU1BPVCIsImZhY2UiLCJsaWdodFJlbmRlckRhdGEiLCJnZXRSZW5kZXJEYXRhIiwic2hhZG93Q2FtIiwic2hhZG93Q2FtZXJhIiwibmVhckNsaXAiLCJhdHRlbnVhdGlvbkVuZCIsImZhckNsaXAiLCJkZXB0aFJhbmdlQ29tcGVuc2F0aW9uIiwic2hhZG93Q2FtTm9kZSIsIl9ub2RlIiwibGlnaHROb2RlIiwic2V0UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImZvdiIsIl9vdXRlckNvbmVBbmdsZSIsInNldFJvdGF0aW9uIiwiZ2V0Um90YXRpb24iLCJyb3RhdGVMb2NhbCIsIkxJR0hUVFlQRV9PTU5JIiwidGlsZVNpemUiLCJsaWdodFRleHR1cmVBdGxhcyIsInNoYWRvd0F0bGFzUmVzb2x1dGlvbiIsImF0bGFzVmlld3BvcnQiLCJ6IiwidGV4ZWxTaXplIiwiZmlsdGVyU2l6ZSIsInNoYWRvd0VkZ2VQaXhlbHMiLCJNYXRoIiwiYXRhbiIsIm1hdGgiLCJSQURfVE9fREVHIiwidXBkYXRlQ2FtZXJhRnJ1c3R1bSIsImN1bGxTaGFkb3dDYXN0ZXJzIiwidmlzaWJsZUNhc3RlcnMiLCJwcmVwYXJlTGlnaHRzIiwibGlnaHRzIiwiaSIsImxlbmd0aCIsIm5lZWRzU2hhZG93UmVuZGVyaW5nIiwiYXRsYXNWaWV3cG9ydEFsbG9jYXRlZCIsInB1c2giLCJudW1TaGFkb3dGYWNlcyIsInByZXBhcmVGYWNlIiwicHJlcGFyZUNsdXN0ZXJlZFJlbmRlclBhc3MiLCJyZW5kZXJQYXNzIiwibG9jYWxMaWdodHMiLCJjb3VudCIsInNldHVwUmVuZGVyUGFzcyIsIl9leGVjdXRlIiwicmVuZGVyRmFjZSIsInNldHVwTm9uQ2x1c3RlcmVkRmFjZVJlbmRlclBhc3MiLCJmcmFtZUdyYXBoIiwiYXBwbHlWc20iLCJSZW5kZXJQYXNzIiwiRGVidWdIZWxwZXIiLCJzZXROYW1lIiwibmFtZSIsIl9hZnRlciIsInJlbmRlclZzbSIsImFkZFJlbmRlclBhc3MiLCJidWlsZE5vbkNsdXN0ZXJlZFJlbmRlclBhc3NlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsbUJBQW1CLENBQUM7QUFhdEJDLEVBQUFBLFdBQVdBLENBQUNDLFFBQVEsRUFBRUMsY0FBYyxFQUFFO0FBWnRDO0lBQUEsSUFDQUMsQ0FBQUEsWUFBWSxHQUFHLEVBQUUsQ0FBQTtBQUVqQjtBQUFBLElBQUEsSUFBQSxDQUNBRixRQUFRLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFFUjtBQUFBLElBQUEsSUFBQSxDQUNBQyxjQUFjLEdBQUEsS0FBQSxDQUFBLENBQUE7QUFFZDtBQUFBLElBQUEsSUFBQSxDQUNBRSxNQUFNLEdBQUEsS0FBQSxDQUFBLENBQUE7SUFHRixJQUFJLENBQUNILFFBQVEsR0FBR0EsUUFBUSxDQUFBO0lBQ3hCLElBQUksQ0FBQ0MsY0FBYyxHQUFHQSxjQUFjLENBQUE7QUFDcEMsSUFBQSxJQUFJLENBQUNFLE1BQU0sR0FBR0gsUUFBUSxDQUFDRyxNQUFNLENBQUE7QUFDakMsR0FBQTs7QUFFQTtFQUNBQyxJQUFJQSxDQUFDQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsT0FBTyxHQUFHLElBQUksRUFBRTtJQUU5QixNQUFNQyxXQUFXLEdBQUcsSUFBSSxDQUFDUixRQUFRLENBQUNTLEtBQUssQ0FBQ0Msd0JBQXdCLENBQUE7O0FBRWhFO0lBQ0FM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
