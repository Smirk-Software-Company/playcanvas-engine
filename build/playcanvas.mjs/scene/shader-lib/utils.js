import { Shader } from '../../platform/graphics/shader.js';
import { ShaderUtils } from '../../platform/graphics/shader-utils.js';
import { shaderChunks } from './chunks/chunks.js';
import { getProgramLibrary } from './get-program-library.js';
import { Debug } from '../../core/debug.js';
import { ShaderGenerator } from './programs/shader-generator.js';

/**
 * Create a shader from named shader chunks.
 *
 * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The
 * graphics device.
 * @param {string} vsName - The vertex shader chunk name.
 * @param {string} fsName - The fragment shader chunk name.
 * @param {boolean} [useTransformFeedback] - Whether to use transform feedback. Defaults to false.
 * @returns {Shader} The newly created shader.
 */
function createShader(device, vsName, fsName, useTransformFeedback = false) {
  return new Shader(device, ShaderUtils.createDefinition(device, {
    name: `${vsName}_${fsName}`,
    vertexCode: shaderChunks[vsName],
    fragmentCode: shaderChunks[fsName],
    useTransformFeedback: useTransformFeedback
  }));
}

/**
 * Create a shader from the supplied source code. Note that this function adds additional shader
 * blocks to both vertex and fragment shaders, which allow the shader to use more features and
 * compile on both WebGL and WebGPU. Specifically, these blocks are added, and should not be
 * part of provided vsCode and fsCode: shader version, shader precision, commonly used extensions.
 *
 * @param {import('../../platform/graphics/graphics-device.js').GraphicsDevice} device - The
 * graphics device.
 * @param {string} vsCode - The vertex shader code.
 * @param {string} fsCode - The fragment shader code.
 * @param {string} uniqueName - Unique name for the shader. If a shader with this name already
 * exists, it will be returned instead of a new shader instance.
 * @param {Object<string, string>} [attributes] - Object detailing the mapping of vertex shader
 * attribute names to semantics SEMANTIC_*. This enables the engine to match vertex buffer data as
 * inputs to the shader. Defaults to undefined, which generates the default attributes.
 * @param {boolean} [useTransformFeedback] - Whether to use transform feedback. Defaults to false.
 * @returns {Shader} The newly created shader.
 */
function createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback = false) {
  // the function signature has changed, fail if called incorrectly
  Debug.assert(typeof attributes !== 'boolean');
  const programLibrary = getProgramLibrary(device);
  let shader = programLibrary.getCachedShader(uniqueName);
  if (!shader) {
    shader = new Shader(device, ShaderUtils.createDefinition(device, {
      name: uniqueName,
      vertexCode: vsCode,
      fragmentCode: fsCode,
      attributes: attributes,
      useTransformFeedback: useTransformFeedback
    }));
    programLibrary.setCachedShader(uniqueName, shader);
  }
  return shader;
}
class ShaderGeneratorPassThrough extends ShaderGenerator {
  constructor(key, shaderDefinition) {
    super();
    this.key = key;
    this.shaderDefinition = shaderDefinition;
  }
  generateKey(options) {
    return this.key;
  }
  createShaderDefinition(device, options) {
    return this.shaderDefinition;
  }
}

/**
 * Process shader using shader processing options, utilizing cache of the ProgramLibrary
 *
 * @param {Shader} shader - The shader to be processed.
 * @param {import('../../platform/graphics/shader-processor-options.js').ShaderProcessorOptions} processingOptions -
 * The shader processing options.
 * @returns {Shader} The processed shader.
 * @ignore
 */
function processShader(shader, processingOptions) {
  var _shaderDefinition$nam;
  Debug.assert(shader);
  const shaderDefinition = shader.definition;

  // 'shader' generator for a material - simply return existing shader definition. Use generator and getProgram
  // to allow for shader processing to be cached
  const name = (_shaderDefinition$nam = shaderDefinition.name) != null ? _shaderDefinition$nam : 'shader';

  // unique name based of the shader id
  const key = `${name}-id-${shader.id}`;
  const materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);

  // temporarily register the program generator
  const libraryModuleName = 'shader';
  const library = getProgramLibrary(shader.device);
  Debug.assert(!library.isRegistered(libraryModuleName));
  library.register(libraryModuleName, materialGenerator);

  // generate shader variant - its the same shader, but with different processing options
  const variant = library.getProgram(libraryModuleName, {}, processingOptions);

  // unregister it again
  library.unregister(libraryModuleName);
  return variant;
}
shaderChunks.createShader = createShader;
shaderChunks.createShaderFromCode = createShaderFromCode;

export { createShader, createShaderFromCode, processShader };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zY2VuZS9zaGFkZXItbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci5qcyc7XG5pbXBvcnQgeyBTaGFkZXJVdGlscyB9IGZyb20gJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci11dGlscy5qcyc7XG5pbXBvcnQgeyBzaGFkZXJDaHVua3MgfSBmcm9tICcuL2NodW5rcy9jaHVua3MuanMnO1xuaW1wb3J0IHsgZ2V0UHJvZ3JhbUxpYnJhcnkgfSBmcm9tICcuL2dldC1wcm9ncmFtLWxpYnJhcnkuanMnO1xuaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IFNoYWRlckdlbmVyYXRvciB9IGZyb20gJy4vcHJvZ3JhbXMvc2hhZGVyLWdlbmVyYXRvci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGEgc2hhZGVyIGZyb20gbmFtZWQgc2hhZGVyIGNodW5rcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vcGxhdGZvcm0vZ3JhcGhpY3MvZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGRldmljZSAtIFRoZVxuICogZ3JhcGhpY3MgZGV2aWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZzTmFtZSAtIFRoZSB2ZXJ0ZXggc2hhZGVyIGNodW5rIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnNOYW1lIC0gVGhlIGZyYWdtZW50IHNoYWRlciBjaHVuayBuYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBbdXNlVHJhbnNmb3JtRmVlZGJhY2tdIC0gV2hldGhlciB0byB1c2UgdHJhbnNmb3JtIGZlZWRiYWNrLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm5zIHtTaGFkZXJ9IFRoZSBuZXdseSBjcmVhdGVkIHNoYWRlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGRldmljZSwgdnNOYW1lLCBmc05hbWUsIHVzZVRyYW5zZm9ybUZlZWRiYWNrID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbmV3IFNoYWRlcihkZXZpY2UsIFNoYWRlclV0aWxzLmNyZWF0ZURlZmluaXRpb24oZGV2aWNlLCB7XG4gICAgICAgIG5hbWU6IGAke3ZzTmFtZX1fJHtmc05hbWV9YCxcbiAgICAgICAgdmVydGV4Q29kZTogc2hhZGVyQ2h1bmtzW3ZzTmFtZV0sXG4gICAgICAgIGZyYWdtZW50Q29kZTogc2hhZGVyQ2h1bmtzW2ZzTmFtZV0sXG4gICAgICAgIHVzZVRyYW5zZm9ybUZlZWRiYWNrOiB1c2VUcmFuc2Zvcm1GZWVkYmFja1xuICAgIH0pKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaGFkZXIgZnJvbSB0aGUgc3VwcGxpZWQgc291cmNlIGNvZGUuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFkZHMgYWRkaXRpb25hbCBzaGFkZXJcbiAqIGJsb2NrcyB0byBib3RoIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycywgd2hpY2ggYWxsb3cgdGhlIHNoYWRlciB0byB1c2UgbW9yZSBmZWF0dXJlcyBhbmRcbiAqIGNvbXBpbGUgb24gYm90aCBXZWJHTCBhbmQgV2ViR1BVLiBTcGVjaWZpY2FsbHksIHRoZXNlIGJsb2NrcyBhcmUgYWRkZWQsIGFuZCBzaG91bGQgbm90IGJlXG4gKiBwYXJ0IG9mIHByb3ZpZGVkIHZzQ29kZSBhbmQgZnNDb2RlOiBzaGFkZXIgdmVyc2lvbiwgc2hhZGVyIHByZWNpc2lvbiwgY29tbW9ubHkgdXNlZCBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9wbGF0Zm9ybS9ncmFwaGljcy9ncmFwaGljcy1kZXZpY2UuanMnKS5HcmFwaGljc0RldmljZX0gZGV2aWNlIC0gVGhlXG4gKiBncmFwaGljcyBkZXZpY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdnNDb2RlIC0gVGhlIHZlcnRleCBzaGFkZXIgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmc0NvZGUgLSBUaGUgZnJhZ21lbnQgc2hhZGVyIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pcXVlTmFtZSAtIFVuaXF1ZSBuYW1lIGZvciB0aGUgc2hhZGVyLiBJZiBhIHNoYWRlciB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5XG4gKiBleGlzdHMsIGl0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhIG5ldyBzaGFkZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthdHRyaWJ1dGVzXSAtIE9iamVjdCBkZXRhaWxpbmcgdGhlIG1hcHBpbmcgb2YgdmVydGV4IHNoYWRlclxuICogYXR0cmlidXRlIG5hbWVzIHRvIHNlbWFudGljcyBTRU1BTlRJQ18qLiBUaGlzIGVuYWJsZXMgdGhlIGVuZ2luZSB0byBtYXRjaCB2ZXJ0ZXggYnVmZmVyIGRhdGEgYXNcbiAqIGlucHV0cyB0byB0aGUgc2hhZGVyLiBEZWZhdWx0cyB0byB1bmRlZmluZWQsIHdoaWNoIGdlbmVyYXRlcyB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtib29sZWFufSBbdXNlVHJhbnNmb3JtRmVlZGJhY2tdIC0gV2hldGhlciB0byB1c2UgdHJhbnNmb3JtIGZlZWRiYWNrLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm5zIHtTaGFkZXJ9IFRoZSBuZXdseSBjcmVhdGVkIHNoYWRlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2hhZGVyRnJvbUNvZGUoZGV2aWNlLCB2c0NvZGUsIGZzQ29kZSwgdW5pcXVlTmFtZSwgYXR0cmlidXRlcywgdXNlVHJhbnNmb3JtRmVlZGJhY2sgPSBmYWxzZSkge1xuXG4gICAgLy8gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXMgY2hhbmdlZCwgZmFpbCBpZiBjYWxsZWQgaW5jb3JyZWN0bHlcbiAgICBEZWJ1Zy5hc3NlcnQodHlwZW9mIGF0dHJpYnV0ZXMgIT09ICdib29sZWFuJyk7XG5cbiAgICBjb25zdCBwcm9ncmFtTGlicmFyeSA9IGdldFByb2dyYW1MaWJyYXJ5KGRldmljZSk7XG4gICAgbGV0IHNoYWRlciA9IHByb2dyYW1MaWJyYXJ5LmdldENhY2hlZFNoYWRlcih1bmlxdWVOYW1lKTtcbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgICBzaGFkZXIgPSBuZXcgU2hhZGVyKGRldmljZSwgU2hhZGVyVXRpbHMuY3JlYXRlRGVmaW5pdGlvbihkZXZpY2UsIHtcbiAgICAgICAgICAgIG5hbWU6IHVuaXF1ZU5hbWUsXG4gICAgICAgICAgICB2ZXJ0ZXhDb2RlOiB2c0NvZGUsXG4gICAgICAgICAgICBmcmFnbWVudENvZGU6IGZzQ29kZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB1c2VUcmFuc2Zvcm1GZWVkYmFjazogdXNlVHJhbnNmb3JtRmVlZGJhY2tcbiAgICAgICAgfSkpO1xuICAgICAgICBwcm9ncmFtTGlicmFyeS5zZXRDYWNoZWRTaGFkZXIodW5pcXVlTmFtZSwgc2hhZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn1cblxuY2xhc3MgU2hhZGVyR2VuZXJhdG9yUGFzc1Rocm91Z2ggZXh0ZW5kcyBTaGFkZXJHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGtleSwgc2hhZGVyRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zaGFkZXJEZWZpbml0aW9uID0gc2hhZGVyRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZUtleShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG5cbiAgICBjcmVhdGVTaGFkZXJEZWZpbml0aW9uKGRldmljZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJEZWZpbml0aW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQcm9jZXNzIHNoYWRlciB1c2luZyBzaGFkZXIgcHJvY2Vzc2luZyBvcHRpb25zLCB1dGlsaXppbmcgY2FjaGUgb2YgdGhlIFByb2dyYW1MaWJyYXJ5XG4gKlxuICogQHBhcmFtIHtTaGFkZXJ9IHNoYWRlciAtIFRoZSBzaGFkZXIgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3BsYXRmb3JtL2dyYXBoaWNzL3NoYWRlci1wcm9jZXNzb3Itb3B0aW9ucy5qcycpLlNoYWRlclByb2Nlc3Nvck9wdGlvbnN9IHByb2Nlc3NpbmdPcHRpb25zIC1cbiAqIFRoZSBzaGFkZXIgcHJvY2Vzc2luZyBvcHRpb25zLlxuICogQHJldHVybnMge1NoYWRlcn0gVGhlIHByb2Nlc3NlZCBzaGFkZXIuXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NTaGFkZXIoc2hhZGVyLCBwcm9jZXNzaW5nT3B0aW9ucykge1xuXG4gICAgRGVidWcuYXNzZXJ0KHNoYWRlcik7XG4gICAgY29uc3Qgc2hhZGVyRGVmaW5pdGlvbiA9IHNoYWRlci5kZWZpbml0aW9uO1xuXG4gICAgLy8gJ3NoYWRlcicgZ2VuZXJhdG9yIGZvciBhIG1hdGVyaWFsIC0gc2ltcGx5IHJldHVybiBleGlzdGluZyBzaGFkZXIgZGVmaW5pdGlvbi4gVXNlIGdlbmVyYXRvciBhbmQgZ2V0UHJvZ3JhbVxuICAgIC8vIHRvIGFsbG93IGZvciBzaGFkZXIgcHJvY2Vzc2luZyB0byBiZSBjYWNoZWRcbiAgICBjb25zdCBuYW1lID0gc2hhZGVyRGVmaW5pdGlvbi5uYW1lID8/ICdzaGFkZXInO1xuXG4gICAgLy8gdW5pcXVlIG5hbWUgYmFzZWQgb2YgdGhlIHNoYWRlciBpZFxuICAgIGNvbnN0IGtleSA9IGAke25hbWV9LWlkLSR7c2hhZGVyLmlkfWA7XG5cbiAgICBjb25zdCBtYXRlcmlhbEdlbmVyYXRvciA9IG5ldyBTaGFkZXJHZW5lcmF0b3JQYXNzVGhyb3VnaChrZXksIHNoYWRlckRlZmluaXRpb24pO1xuXG4gICAgLy8gdGVtcG9yYXJpbHkgcmVnaXN0ZXIgdGhlIHByb2dyYW0gZ2VuZXJhdG9yXG4gICAgY29uc3QgbGlicmFyeU1vZHVsZU5hbWUgPSAnc2hhZGVyJztcbiAgICBjb25zdCBsaWJyYXJ5ID0gZ2V0UHJvZ3JhbUxpYnJhcnkoc2hhZGVyLmRldmljZSk7XG4gICAgRGVidWcuYXNzZXJ0KCFsaWJyYXJ5LmlzUmVnaXN0ZXJlZChsaWJyYXJ5TW9kdWxlTmFtZSkpO1xuICAgIGxpYnJhcnkucmVnaXN0ZXIobGlicmFyeU1vZHVsZU5hbWUsIG1hdGVyaWFsR2VuZXJhdG9yKTtcblxuICAgIC8vIGdlbmVyYXRlIHNoYWRlciB2YXJpYW50IC0gaXRzIHRoZSBzYW1lIHNoYWRlciwgYnV0IHdpdGggZGlmZmVyZW50IHByb2Nlc3Npbmcgb3B0aW9uc1xuICAgIGNvbnN0IHZhcmlhbnQgPSBsaWJyYXJ5LmdldFByb2dyYW0obGlicmFyeU1vZHVsZU5hbWUsIHt9LCBwcm9jZXNzaW5nT3B0aW9ucyk7XG5cbiAgICAvLyB1bnJlZ2lzdGVyIGl0IGFnYWluXG4gICAgbGlicmFyeS51bnJlZ2lzdGVyKGxpYnJhcnlNb2R1bGVOYW1lKTtcblxuICAgIHJldHVybiB2YXJpYW50O1xufVxuXG5cbnNoYWRlckNodW5rcy5jcmVhdGVTaGFkZXIgPSBjcmVhdGVTaGFkZXI7XG5zaGFkZXJDaHVua3MuY3JlYXRlU2hhZGVyRnJvbUNvZGUgPSBjcmVhdGVTaGFkZXJGcm9tQ29kZTtcblxuZXhwb3J0IHsgY3JlYXRlU2hhZGVyLCBjcmVhdGVTaGFkZXJGcm9tQ29kZSwgcHJvY2Vzc1NoYWRlciB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVNoYWRlciIsImRldmljZSIsInZzTmFtZSIsImZzTmFtZSIsInVzZVRyYW5zZm9ybUZlZWRiYWNrIiwiU2hhZGVyIiwiU2hhZGVyVXRpbHMiLCJjcmVhdGVEZWZpbml0aW9uIiwibmFtZSIsInZlcnRleENvZGUiLCJzaGFkZXJDaHVua3MiLCJmcmFnbWVudENvZGUiLCJjcmVhdGVTaGFkZXJGcm9tQ29kZSIsInZzQ29kZSIsImZzQ29kZSIsInVuaXF1ZU5hbWUiLCJhdHRyaWJ1dGVzIiwiRGVidWciLCJhc3NlcnQiLCJwcm9ncmFtTGlicmFyeSIsImdldFByb2dyYW1MaWJyYXJ5Iiwic2hhZGVyIiwiZ2V0Q2FjaGVkU2hhZGVyIiwic2V0Q2FjaGVkU2hhZGVyIiwiU2hhZGVyR2VuZXJhdG9yUGFzc1Rocm91Z2giLCJTaGFkZXJHZW5lcmF0b3IiLCJjb25zdHJ1Y3RvciIsImtleSIsInNoYWRlckRlZmluaXRpb24iLCJnZW5lcmF0ZUtleSIsIm9wdGlvbnMiLCJjcmVhdGVTaGFkZXJEZWZpbml0aW9uIiwicHJvY2Vzc1NoYWRlciIsInByb2Nlc3NpbmdPcHRpb25zIiwiX3NoYWRlckRlZmluaXRpb24kbmFtIiwiZGVmaW5pdGlvbiIsImlkIiwibWF0ZXJpYWxHZW5lcmF0b3IiLCJsaWJyYXJ5TW9kdWxlTmFtZSIsImxpYnJhcnkiLCJpc1JlZ2lzdGVyZWQiLCJyZWdpc3RlciIsInZhcmlhbnQiLCJnZXRQcm9ncmFtIiwidW5yZWdpc3RlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0EsWUFBWUEsQ0FBQ0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsb0JBQW9CLEdBQUcsS0FBSyxFQUFFO0VBQ3hFLE9BQU8sSUFBSUMsTUFBTSxDQUFDSixNQUFNLEVBQUVLLFdBQVcsQ0FBQ0MsZ0JBQWdCLENBQUNOLE1BQU0sRUFBRTtBQUMzRE8sSUFBQUEsSUFBSSxFQUFHLENBQUEsRUFBRU4sTUFBTyxDQUFBLENBQUEsRUFBR0MsTUFBTyxDQUFDLENBQUE7QUFDM0JNLElBQUFBLFVBQVUsRUFBRUMsWUFBWSxDQUFDUixNQUFNLENBQUM7QUFDaENTLElBQUFBLFlBQVksRUFBRUQsWUFBWSxDQUFDUCxNQUFNLENBQUM7QUFDbENDLElBQUFBLG9CQUFvQixFQUFFQSxvQkFBQUE7QUFDMUIsR0FBQyxDQUFD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
