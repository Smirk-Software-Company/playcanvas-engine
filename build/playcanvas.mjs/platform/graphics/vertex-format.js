import { Debug } from '../../core/debug.js';
import { hashCode } from '../../core/hash.js';
import { math } from '../../core/math/math.js';
import { StringIds } from '../../core/string-ids.js';
import { typedArrayTypesByteSize, vertexTypesNames, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_COLOR, SEMANTIC_TANGENT, SEMANTIC_ATTR12, TYPE_FLOAT32, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15 } from './constants.js';

const stringIds = new StringIds();

/**
 * A vertex format is a descriptor that defines the layout of vertex data inside a
 * {@link VertexBuffer}.
 *
 * @property {object[]} elements The vertex attribute elements.
 * @property {string} elements[].name The meaning of the vertex element. This is used to link the
 * vertex data to a shader input. Can be:
 *
 * - {@link SEMANTIC_POSITION}
 * - {@link SEMANTIC_NORMAL}
 * - {@link SEMANTIC_TANGENT}
 * - {@link SEMANTIC_BLENDWEIGHT}
 * - {@link SEMANTIC_BLENDINDICES}
 * - {@link SEMANTIC_COLOR}
 * - {@link SEMANTIC_TEXCOORD0}
 * - {@link SEMANTIC_TEXCOORD1}
 * - {@link SEMANTIC_TEXCOORD2}
 * - {@link SEMANTIC_TEXCOORD3}
 * - {@link SEMANTIC_TEXCOORD4}
 * - {@link SEMANTIC_TEXCOORD5}
 * - {@link SEMANTIC_TEXCOORD6}
 * - {@link SEMANTIC_TEXCOORD7}
 *
 * If vertex data has a meaning other that one of those listed above, use the user-defined
 * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
 * @property {number} elements[].numComponents The number of components of the vertex attribute.
 * Can be 1, 2, 3 or 4.
 * @property {number} elements[].dataType The data type of the attribute. Can be:
 *
 * - {@link TYPE_INT8}
 * - {@link TYPE_UINT8}
 * - {@link TYPE_INT16}
 * - {@link TYPE_UINT16}
 * - {@link TYPE_INT32}
 * - {@link TYPE_UINT32}
 * - {@link TYPE_FLOAT32}
 * @property {boolean} elements[].normalize If true, vertex attribute data will be mapped from a 0
 * to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data is left
 * unchanged. If this property is unspecified, false is assumed.
 * @property {number} elements[].offset The number of initial bytes at the start of a vertex that
 * are not relevant to this attribute.
 * @property {number} elements[].stride The number of total bytes that are between the start of one
 * vertex, and the start of the next.
 * @property {number} elements[].size The size of the attribute in bytes.
 * @category Graphics
 */
class VertexFormat {
  /**
   * Create a new VertexFormat instance.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to manage this vertex format.
   * @param {object[]} description - An array of vertex attribute descriptions.
   * @param {string} description[].semantic - The meaning of the vertex element. This is used to
   * link the vertex data to a shader input. Can be:
   *
   * - {@link SEMANTIC_POSITION}
   * - {@link SEMANTIC_NORMAL}
   * - {@link SEMANTIC_TANGENT}
   * - {@link SEMANTIC_BLENDWEIGHT}
   * - {@link SEMANTIC_BLENDINDICES}
   * - {@link SEMANTIC_COLOR}
   * - {@link SEMANTIC_TEXCOORD0}
   * - {@link SEMANTIC_TEXCOORD1}
   * - {@link SEMANTIC_TEXCOORD2}
   * - {@link SEMANTIC_TEXCOORD3}
   * - {@link SEMANTIC_TEXCOORD4}
   * - {@link SEMANTIC_TEXCOORD5}
   * - {@link SEMANTIC_TEXCOORD6}
   * - {@link SEMANTIC_TEXCOORD7}
   *
   * If vertex data has a meaning other that one of those listed above, use the user-defined
   * semantics: {@link SEMANTIC_ATTR0} to {@link SEMANTIC_ATTR15}.
   * @param {number} description[].components - The number of components of the vertex attribute.
   * Can be 1, 2, 3 or 4.
   * @param {number} description[].type - The data type of the attribute. Can be:
   *
   * - {@link TYPE_INT8}
   * - {@link TYPE_UINT8}
   * - {@link TYPE_INT16}
   * - {@link TYPE_UINT16}
   * - {@link TYPE_INT32}
   * - {@link TYPE_UINT32}
   * - {@link TYPE_FLOAT32}
   *
   * @param {boolean} [description[].normalize] - If true, vertex attribute data will be mapped
   * from a 0 to 255 range down to 0 to 1 when fed to a shader. If false, vertex attribute data
   * is left unchanged. If this property is unspecified, false is assumed.
   * @param {number} [vertexCount] - When specified, vertex format will be set up for
   * non-interleaved format with a specified number of vertices. (example: PPPPNNNNCCCC), where
   * arrays of individual attributes will be stored one right after the other (subject to
   * alignment requirements). Note that in this case, the format depends on the number of
   * vertices, and needs to change when the number of vertices changes. When not specified,
   * vertex format will be interleaved. (example: PNCPNCPNCPNC).
   * @example
   * // Specify 3-component positions (x, y, z)
   * const vertexFormat = new pc.VertexFormat(graphicsDevice, [
   *     { semantic: pc.SEMANTIC_POSITION, components: 3, type: pc.TYPE_FLOAT32 }
   * ]);
   * @example
   * // Specify 2-component positions (x, y), a texture coordinate (u, v) and a vertex color (r, g, b, a)
   * const vertexFormat = new pc.VertexFormat(graphicsDevice, [
   *     { semantic: pc.SEMANTIC_POSITION, components: 2, type: pc.TYPE_FLOAT32 },
   *     { semantic: pc.SEMANTIC_TEXCOORD0, components: 2, type: pc.TYPE_FLOAT32 },
   *     { semantic: pc.SEMANTIC_COLOR, components: 4, type: pc.TYPE_UINT8, normalize: true }
   * ]);
   */
  constructor(graphicsDevice, description, vertexCount) {
    this.device = graphicsDevice;
    this._elements = [];
    this.hasUv0 = false;
    this.hasUv1 = false;
    this.hasColor = false;
    this.hasTangents = false;
    this.verticesByteSize = 0;
    this.vertexCount = vertexCount;
    this.interleaved = vertexCount === undefined;

    // true if the vertex format represents an instancing vertex buffer
    this.instancing = false;

    // calculate total size of the vertex
    this.size = description.reduce((total, desc) => {
      return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
    }, 0);
    let offset = 0,
      elementSize;
    for (let i = 0, len = description.length; i < len; i++) {
      var _elementDesc$normaliz;
      const elementDesc = description[i];
      elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];

      // WebGPU has limited element size support (for example uint16x3 is not supported)
      Debug.assert(!graphicsDevice.isWebGPU || [2, 4, 8, 12, 16].includes(elementSize), `WebGPU does not support the format of vertex element ${elementDesc.semantic} : ${vertexTypesNames[elementDesc.type]} x ${elementDesc.components}`);

      // align up the offset to elementSize (when vertexCount is specified only - case of non-interleaved format)
      if (vertexCount) {
        offset = math.roundUp(offset, elementSize);

        // non-interleaved format with elementSize not multiple of 4 might be slower on some platforms - padding is recommended to align its size
        // example: use 4 x TYPE_UINT8 instead of 3 x TYPE_UINT8
        Debug.assert(elementSize % 4 === 0, `Non-interleaved vertex format with element size not multiple of 4 can have performance impact on some platforms. Element size: ${elementSize}`);
      }
      const element = {
        name: elementDesc.semantic,
        offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
        stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
        dataType: elementDesc.type,
        numComponents: elementDesc.components,
        normalize: (_elementDesc$normaliz = elementDesc.normalize) != null ? _elementDesc$normaliz : false,
        size: elementSize
      };
      this._elements.push(element);
      if (vertexCount) {
        offset += elementSize * vertexCount;
      } else {
        offset += Math.ceil(elementSize / 4) * 4;
      }
      if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
        this.hasUv0 = true;
      } else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
        this.hasUv1 = true;
      } else if (elementDesc.semantic === SEMANTIC_COLOR) {
        this.hasColor = true;
      } else if (elementDesc.semantic === SEMANTIC_TANGENT) {
        this.hasTangents = true;
      }
    }
    if (vertexCount) {
      this.verticesByteSize = offset;
    }
    this._evaluateHash();
  }
  get elements() {
    return this._elements;
  }

  /**
   * @type {VertexFormat}
   * @private
   */

  /**
   * The {@link VertexFormat} used to store matrices of type {@link Mat4} for hardware instancing.
   *
   * @param {import('./graphics-device.js').GraphicsDevice} graphicsDevice - The graphics device
   * used to create this vertex format.
   *
   * @returns {VertexFormat} The default instancing vertex format.
   */
  static getDefaultInstancingFormat(graphicsDevice) {
    if (!VertexFormat._defaultInstancingFormat) {
      VertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, [{
        semantic: SEMANTIC_ATTR12,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR13,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR14,
        components: 4,
        type: TYPE_FLOAT32
      }, {
        semantic: SEMANTIC_ATTR15,
        components: 4,
        type: TYPE_FLOAT32
      }]);
    }
    return VertexFormat._defaultInstancingFormat;
  }

  /**
   * Applies any changes made to the VertexFormat's properties.
   *
   * @private
   */
  update() {
    // Note that this is used only by vertex attribute morphing on the WebGL.
    Debug.assert(!this.device.isWebGPU, `VertexFormat#update is not supported on WebGPU and VertexFormat cannot be modified.`);
    this._evaluateHash();
  }

  /**
   * Evaluates hash values for the format allowing fast compare of batching / rendering compatibility.
   *
   * @private
   */
  _evaluateHash() {
    let stringElementBatch;
    const stringElementsBatch = [];
    let stringElementRender;
    const stringElementsRender = [];
    const len = this._elements.length;
    for (let i = 0; i < len; i++) {
      const element = this._elements[i];

      // create string description of each element that is relevant for batching
      stringElementBatch = element.name;
      stringElementBatch += element.dataType;
      stringElementBatch += element.numComponents;
      stringElementBatch += element.normalize;
      stringElementsBatch.push(stringElementBatch);

      // create string description of each element that is relevant for rendering
      stringElementRender = stringElementBatch;
      stringElementRender += element.offset;
      stringElementRender += element.stride;
      stringElementRender += element.size;
      stringElementsRender.push(stringElementRender);
    }

    // sort batching ones alphabetically to make the hash order independent
    stringElementsBatch.sort();
    this.batchingHash = hashCode(stringElementsBatch.join());

    // rendering hash
    this.renderingHashString = stringElementsRender.join('_');
    this.renderingHash = stringIds.get(this.renderingHashString);
  }
}
VertexFormat._defaultInstancingFormat = null;

export { VertexFormat };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVydGV4LWZvcm1hdC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3BsYXRmb3JtL2dyYXBoaWNzL3ZlcnRleC1mb3JtYXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVidWcgfSBmcm9tICcuLi8uLi9jb3JlL2RlYnVnLmpzJztcbmltcG9ydCB7IGhhc2hDb2RlIH0gZnJvbSAnLi4vLi4vY29yZS9oYXNoLmpzJztcblxuaW1wb3J0IHsgbWF0aCB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aC9tYXRoLmpzJztcbmltcG9ydCB7IFN0cmluZ0lkcyB9IGZyb20gJy4uLy4uL2NvcmUvc3RyaW5nLWlkcy5qcyc7XG5cbmltcG9ydCB7XG4gICAgU0VNQU5USUNfVEVYQ09PUkQwLCBTRU1BTlRJQ19URVhDT09SRDEsIFNFTUFOVElDX0FUVFIxMiwgU0VNQU5USUNfQVRUUjEzLCBTRU1BTlRJQ19BVFRSMTQsIFNFTUFOVElDX0FUVFIxNSxcbiAgICBTRU1BTlRJQ19DT0xPUiwgU0VNQU5USUNfVEFOR0VOVCwgVFlQRV9GTE9BVDMyLCB0eXBlZEFycmF5VHlwZXNCeXRlU2l6ZSwgdmVydGV4VHlwZXNOYW1lc1xufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IHN0cmluZ0lkcyA9IG5ldyBTdHJpbmdJZHMoKTtcblxuLyoqXG4gKiBBIHZlcnRleCBmb3JtYXQgaXMgYSBkZXNjcmlwdG9yIHRoYXQgZGVmaW5lcyB0aGUgbGF5b3V0IG9mIHZlcnRleCBkYXRhIGluc2lkZSBhXG4gKiB7QGxpbmsgVmVydGV4QnVmZmVyfS5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdFtdfSBlbGVtZW50cyBUaGUgdmVydGV4IGF0dHJpYnV0ZSBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbGVtZW50c1tdLm5hbWUgVGhlIG1lYW5pbmcgb2YgdGhlIHZlcnRleCBlbGVtZW50LiBUaGlzIGlzIHVzZWQgdG8gbGluayB0aGVcbiAqIHZlcnRleCBkYXRhIHRvIGEgc2hhZGVyIGlucHV0LiBDYW4gYmU6XG4gKlxuICogLSB7QGxpbmsgU0VNQU5USUNfUE9TSVRJT059XG4gKiAtIHtAbGluayBTRU1BTlRJQ19OT1JNQUx9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19UQU5HRU5UfVxuICogLSB7QGxpbmsgU0VNQU5USUNfQkxFTkRXRUlHSFR9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19CTEVORElORElDRVN9XG4gKiAtIHtAbGluayBTRU1BTlRJQ19DT0xPUn1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMH1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMX1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMn1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEM31cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENH1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENX1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENn1cbiAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEN31cbiAqXG4gKiBJZiB2ZXJ0ZXggZGF0YSBoYXMgYSBtZWFuaW5nIG90aGVyIHRoYXQgb25lIG9mIHRob3NlIGxpc3RlZCBhYm92ZSwgdXNlIHRoZSB1c2VyLWRlZmluZWRcbiAqIHNlbWFudGljczoge0BsaW5rIFNFTUFOVElDX0FUVFIwfSB0byB7QGxpbmsgU0VNQU5USUNfQVRUUjE1fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLm51bUNvbXBvbmVudHMgVGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLlxuICogQ2FuIGJlIDEsIDIsIDMgb3IgNC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLmRhdGFUeXBlIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZS4gQ2FuIGJlOlxuICpcbiAqIC0ge0BsaW5rIFRZUEVfSU5UOH1cbiAqIC0ge0BsaW5rIFRZUEVfVUlOVDh9XG4gKiAtIHtAbGluayBUWVBFX0lOVDE2fVxuICogLSB7QGxpbmsgVFlQRV9VSU5UMTZ9XG4gKiAtIHtAbGluayBUWVBFX0lOVDMyfVxuICogLSB7QGxpbmsgVFlQRV9VSU5UMzJ9XG4gKiAtIHtAbGluayBUWVBFX0ZMT0FUMzJ9XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVsZW1lbnRzW10ubm9ybWFsaXplIElmIHRydWUsIHZlcnRleCBhdHRyaWJ1dGUgZGF0YSB3aWxsIGJlIG1hcHBlZCBmcm9tIGEgMFxuICogdG8gMjU1IHJhbmdlIGRvd24gdG8gMCB0byAxIHdoZW4gZmVkIHRvIGEgc2hhZGVyLiBJZiBmYWxzZSwgdmVydGV4IGF0dHJpYnV0ZSBkYXRhIGlzIGxlZnRcbiAqIHVuY2hhbmdlZC4gSWYgdGhpcyBwcm9wZXJ0eSBpcyB1bnNwZWNpZmllZCwgZmFsc2UgaXMgYXNzdW1lZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLm9mZnNldCBUaGUgbnVtYmVyIG9mIGluaXRpYWwgYnl0ZXMgYXQgdGhlIHN0YXJ0IG9mIGEgdmVydGV4IHRoYXRcbiAqIGFyZSBub3QgcmVsZXZhbnQgdG8gdGhpcyBhdHRyaWJ1dGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudHNbXS5zdHJpZGUgVGhlIG51bWJlciBvZiB0b3RhbCBieXRlcyB0aGF0IGFyZSBiZXR3ZWVuIHRoZSBzdGFydCBvZiBvbmVcbiAqIHZlcnRleCwgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50c1tdLnNpemUgVGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZSBpbiBieXRlcy5cbiAqIEBjYXRlZ29yeSBHcmFwaGljc1xuICovXG5jbGFzcyBWZXJ0ZXhGb3JtYXQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBWZXJ0ZXhGb3JtYXQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9ncmFwaGljcy1kZXZpY2UuanMnKS5HcmFwaGljc0RldmljZX0gZ3JhcGhpY3NEZXZpY2UgLSBUaGUgZ3JhcGhpY3MgZGV2aWNlXG4gICAgICogdXNlZCB0byBtYW5hZ2UgdGhpcyB2ZXJ0ZXggZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRlc2NyaXB0aW9uIC0gQW4gYXJyYXkgb2YgdmVydGV4IGF0dHJpYnV0ZSBkZXNjcmlwdGlvbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlc2NyaXB0aW9uW10uc2VtYW50aWMgLSBUaGUgbWVhbmluZyBvZiB0aGUgdmVydGV4IGVsZW1lbnQuIFRoaXMgaXMgdXNlZCB0b1xuICAgICAqIGxpbmsgdGhlIHZlcnRleCBkYXRhIHRvIGEgc2hhZGVyIGlucHV0LiBDYW4gYmU6XG4gICAgICpcbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19QT1NJVElPTn1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19OT1JNQUx9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEFOR0VOVH1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19CTEVORFdFSUdIVH1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19CTEVORElORElDRVN9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfQ09MT1J9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQwfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEMX1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDJ9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQzfVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JENH1cbiAgICAgKiAtIHtAbGluayBTRU1BTlRJQ19URVhDT09SRDV9XG4gICAgICogLSB7QGxpbmsgU0VNQU5USUNfVEVYQ09PUkQ2fVxuICAgICAqIC0ge0BsaW5rIFNFTUFOVElDX1RFWENPT1JEN31cbiAgICAgKlxuICAgICAqIElmIHZlcnRleCBkYXRhIGhhcyBhIG1lYW5pbmcgb3RoZXIgdGhhdCBvbmUgb2YgdGhvc2UgbGlzdGVkIGFib3ZlLCB1c2UgdGhlIHVzZXItZGVmaW5lZFxuICAgICAqIHNlbWFudGljczoge0BsaW5rIFNFTUFOVElDX0FUVFIwfSB0byB7QGxpbmsgU0VNQU5USUNfQVRUUjE1fS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVzY3JpcHRpb25bXS5jb21wb25lbnRzIC0gVGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLlxuICAgICAqIENhbiBiZSAxLCAyLCAzIG9yIDQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc2NyaXB0aW9uW10udHlwZSAtIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZS4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSB7QGxpbmsgVFlQRV9JTlQ4fVxuICAgICAqIC0ge0BsaW5rIFRZUEVfVUlOVDh9XG4gICAgICogLSB7QGxpbmsgVFlQRV9JTlQxNn1cbiAgICAgKiAtIHtAbGluayBUWVBFX1VJTlQxNn1cbiAgICAgKiAtIHtAbGluayBUWVBFX0lOVDMyfVxuICAgICAqIC0ge0BsaW5rIFRZUEVfVUlOVDMyfVxuICAgICAqIC0ge0BsaW5rIFRZUEVfRkxPQVQzMn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc2NyaXB0aW9uW10ubm9ybWFsaXplXSAtIElmIHRydWUsIHZlcnRleCBhdHRyaWJ1dGUgZGF0YSB3aWxsIGJlIG1hcHBlZFxuICAgICAqIGZyb20gYSAwIHRvIDI1NSByYW5nZSBkb3duIHRvIDAgdG8gMSB3aGVuIGZlZCB0byBhIHNoYWRlci4gSWYgZmFsc2UsIHZlcnRleCBhdHRyaWJ1dGUgZGF0YVxuICAgICAqIGlzIGxlZnQgdW5jaGFuZ2VkLiBJZiB0aGlzIHByb3BlcnR5IGlzIHVuc3BlY2lmaWVkLCBmYWxzZSBpcyBhc3N1bWVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmVydGV4Q291bnRdIC0gV2hlbiBzcGVjaWZpZWQsIHZlcnRleCBmb3JtYXQgd2lsbCBiZSBzZXQgdXAgZm9yXG4gICAgICogbm9uLWludGVybGVhdmVkIGZvcm1hdCB3aXRoIGEgc3BlY2lmaWVkIG51bWJlciBvZiB2ZXJ0aWNlcy4gKGV4YW1wbGU6IFBQUFBOTk5OQ0NDQyksIHdoZXJlXG4gICAgICogYXJyYXlzIG9mIGluZGl2aWR1YWwgYXR0cmlidXRlcyB3aWxsIGJlIHN0b3JlZCBvbmUgcmlnaHQgYWZ0ZXIgdGhlIG90aGVyIChzdWJqZWN0IHRvXG4gICAgICogYWxpZ25tZW50IHJlcXVpcmVtZW50cykuIE5vdGUgdGhhdCBpbiB0aGlzIGNhc2UsIHRoZSBmb3JtYXQgZGVwZW5kcyBvbiB0aGUgbnVtYmVyIG9mXG4gICAgICogdmVydGljZXMsIGFuZCBuZWVkcyB0byBjaGFuZ2Ugd2hlbiB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGNoYW5nZXMuIFdoZW4gbm90IHNwZWNpZmllZCxcbiAgICAgKiB2ZXJ0ZXggZm9ybWF0IHdpbGwgYmUgaW50ZXJsZWF2ZWQuIChleGFtcGxlOiBQTkNQTkNQTkNQTkMpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU3BlY2lmeSAzLWNvbXBvbmVudCBwb3NpdGlvbnMgKHgsIHksIHopXG4gICAgICogY29uc3QgdmVydGV4Rm9ybWF0ID0gbmV3IHBjLlZlcnRleEZvcm1hdChncmFwaGljc0RldmljZSwgW1xuICAgICAqICAgICB7IHNlbWFudGljOiBwYy5TRU1BTlRJQ19QT1NJVElPTiwgY29tcG9uZW50czogMywgdHlwZTogcGMuVFlQRV9GTE9BVDMyIH1cbiAgICAgKiBdKTtcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFNwZWNpZnkgMi1jb21wb25lbnQgcG9zaXRpb25zICh4LCB5KSwgYSB0ZXh0dXJlIGNvb3JkaW5hdGUgKHUsIHYpIGFuZCBhIHZlcnRleCBjb2xvciAociwgZywgYiwgYSlcbiAgICAgKiBjb25zdCB2ZXJ0ZXhGb3JtYXQgPSBuZXcgcGMuVmVydGV4Rm9ybWF0KGdyYXBoaWNzRGV2aWNlLCBbXG4gICAgICogICAgIHsgc2VtYW50aWM6IHBjLlNFTUFOVElDX1BPU0lUSU9OLCBjb21wb25lbnRzOiAyLCB0eXBlOiBwYy5UWVBFX0ZMT0FUMzIgfSxcbiAgICAgKiAgICAgeyBzZW1hbnRpYzogcGMuU0VNQU5USUNfVEVYQ09PUkQwLCBjb21wb25lbnRzOiAyLCB0eXBlOiBwYy5UWVBFX0ZMT0FUMzIgfSxcbiAgICAgKiAgICAgeyBzZW1hbnRpYzogcGMuU0VNQU5USUNfQ09MT1IsIGNvbXBvbmVudHM6IDQsIHR5cGU6IHBjLlRZUEVfVUlOVDgsIG5vcm1hbGl6ZTogdHJ1ZSB9XG4gICAgICogXSk7XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3JhcGhpY3NEZXZpY2UsIGRlc2NyaXB0aW9uLCB2ZXJ0ZXhDb3VudCkge1xuICAgICAgICB0aGlzLmRldmljZSA9IGdyYXBoaWNzRGV2aWNlO1xuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmhhc1V2MCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1V2MSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0NvbG9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzVGFuZ2VudHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0J5dGVTaXplID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuICAgICAgICB0aGlzLmludGVybGVhdmVkID0gdmVydGV4Q291bnQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyB0cnVlIGlmIHRoZSB2ZXJ0ZXggZm9ybWF0IHJlcHJlc2VudHMgYW4gaW5zdGFuY2luZyB2ZXJ0ZXggYnVmZmVyXG4gICAgICAgIHRoaXMuaW5zdGFuY2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBzaXplIG9mIHRoZSB2ZXJ0ZXhcbiAgICAgICAgdGhpcy5zaXplID0gZGVzY3JpcHRpb24ucmVkdWNlKCh0b3RhbCwgZGVzYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgTWF0aC5jZWlsKGRlc2MuY29tcG9uZW50cyAqIHR5cGVkQXJyYXlUeXBlc0J5dGVTaXplW2Rlc2MudHlwZV0gLyA0KSAqIDQ7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwLCBlbGVtZW50U2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRlc2NyaXB0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50RGVzYyA9IGRlc2NyaXB0aW9uW2ldO1xuXG4gICAgICAgICAgICBlbGVtZW50U2l6ZSA9IGVsZW1lbnREZXNjLmNvbXBvbmVudHMgKiB0eXBlZEFycmF5VHlwZXNCeXRlU2l6ZVtlbGVtZW50RGVzYy50eXBlXTtcblxuICAgICAgICAgICAgLy8gV2ViR1BVIGhhcyBsaW1pdGVkIGVsZW1lbnQgc2l6ZSBzdXBwb3J0IChmb3IgZXhhbXBsZSB1aW50MTZ4MyBpcyBub3Qgc3VwcG9ydGVkKVxuICAgICAgICAgICAgRGVidWcuYXNzZXJ0KCFncmFwaGljc0RldmljZS5pc1dlYkdQVSB8fCBbMiwgNCwgOCwgMTIsIDE2XS5pbmNsdWRlcyhlbGVtZW50U2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgYFdlYkdQVSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmb3JtYXQgb2YgdmVydGV4IGVsZW1lbnQgJHtlbGVtZW50RGVzYy5zZW1hbnRpY30gOiAke3ZlcnRleFR5cGVzTmFtZXNbZWxlbWVudERlc2MudHlwZV19IHggJHtlbGVtZW50RGVzYy5jb21wb25lbnRzfWApO1xuXG4gICAgICAgICAgICAvLyBhbGlnbiB1cCB0aGUgb2Zmc2V0IHRvIGVsZW1lbnRTaXplICh3aGVuIHZlcnRleENvdW50IGlzIHNwZWNpZmllZCBvbmx5IC0gY2FzZSBvZiBub24taW50ZXJsZWF2ZWQgZm9ybWF0KVxuICAgICAgICAgICAgaWYgKHZlcnRleENvdW50KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF0aC5yb3VuZFVwKG9mZnNldCwgZWxlbWVudFNpemUpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm9uLWludGVybGVhdmVkIGZvcm1hdCB3aXRoIGVsZW1lbnRTaXplIG5vdCBtdWx0aXBsZSBvZiA0IG1pZ2h0IGJlIHNsb3dlciBvbiBzb21lIHBsYXRmb3JtcyAtIHBhZGRpbmcgaXMgcmVjb21tZW5kZWQgdG8gYWxpZ24gaXRzIHNpemVcbiAgICAgICAgICAgICAgICAvLyBleGFtcGxlOiB1c2UgNCB4IFRZUEVfVUlOVDggaW5zdGVhZCBvZiAzIHggVFlQRV9VSU5UOFxuICAgICAgICAgICAgICAgIERlYnVnLmFzc2VydCgoZWxlbWVudFNpemUgJSA0KSA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE5vbi1pbnRlcmxlYXZlZCB2ZXJ0ZXggZm9ybWF0IHdpdGggZWxlbWVudCBzaXplIG5vdCBtdWx0aXBsZSBvZiA0IGNhbiBoYXZlIHBlcmZvcm1hbmNlIGltcGFjdCBvbiBzb21lIHBsYXRmb3Jtcy4gRWxlbWVudCBzaXplOiAke2VsZW1lbnRTaXplfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnREZXNjLnNlbWFudGljLFxuICAgICAgICAgICAgICAgIG9mZnNldDogKHZlcnRleENvdW50ID8gb2Zmc2V0IDogKGVsZW1lbnREZXNjLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSA/IGVsZW1lbnREZXNjLm9mZnNldCA6IG9mZnNldCkpLFxuICAgICAgICAgICAgICAgIHN0cmlkZTogKHZlcnRleENvdW50ID8gZWxlbWVudFNpemUgOiAoZWxlbWVudERlc2MuaGFzT3duUHJvcGVydHkoJ3N0cmlkZScpID8gZWxlbWVudERlc2Muc3RyaWRlIDogdGhpcy5zaXplKSksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IGVsZW1lbnREZXNjLnR5cGUsXG4gICAgICAgICAgICAgICAgbnVtQ29tcG9uZW50czogZWxlbWVudERlc2MuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBub3JtYWxpemU6IGVsZW1lbnREZXNjLm5vcm1hbGl6ZSA/PyBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaXplOiBlbGVtZW50U2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBlbGVtZW50U2l6ZSAqIHZlcnRleENvdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gTWF0aC5jZWlsKGVsZW1lbnRTaXplIC8gNCkgKiA0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudERlc2Muc2VtYW50aWMgPT09IFNFTUFOVElDX1RFWENPT1JEMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVXYwID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudERlc2Muc2VtYW50aWMgPT09IFNFTUFOVElDX1RFWENPT1JEMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVXYxID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudERlc2Muc2VtYW50aWMgPT09IFNFTUFOVElDX0NPTE9SKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNDb2xvciA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnREZXNjLnNlbWFudGljID09PSBTRU1BTlRJQ19UQU5HRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVydGV4Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNCeXRlU2l6ZSA9IG9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2YWx1YXRlSGFzaCgpO1xuICAgIH1cblxuICAgIGdldCBlbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtWZXJ0ZXhGb3JtYXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2RlZmF1bHRJbnN0YW5jaW5nRm9ybWF0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgVmVydGV4Rm9ybWF0fSB1c2VkIHRvIHN0b3JlIG1hdHJpY2VzIG9mIHR5cGUge0BsaW5rIE1hdDR9IGZvciBoYXJkd2FyZSBpbnN0YW5jaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ3JhcGhpY3MtZGV2aWNlLmpzJykuR3JhcGhpY3NEZXZpY2V9IGdyYXBoaWNzRGV2aWNlIC0gVGhlIGdyYXBoaWNzIGRldmljZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIHRoaXMgdmVydGV4IGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtWZXJ0ZXhGb3JtYXR9IFRoZSBkZWZhdWx0IGluc3RhbmNpbmcgdmVydGV4IGZvcm1hdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEluc3RhbmNpbmdGb3JtYXQoZ3JhcGhpY3NEZXZpY2UpIHtcblxuICAgICAgICBpZiAoIVZlcnRleEZvcm1hdC5fZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQpIHtcbiAgICAgICAgICAgIFZlcnRleEZvcm1hdC5fZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQgPSBuZXcgVmVydGV4Rm9ybWF0KGdyYXBoaWNzRGV2aWNlLCBbXG4gICAgICAgICAgICAgICAgeyBzZW1hbnRpYzogU0VNQU5USUNfQVRUUjEyLCBjb21wb25lbnRzOiA0LCB0eXBlOiBUWVBFX0ZMT0FUMzIgfSxcbiAgICAgICAgICAgICAgICB7IHNlbWFudGljOiBTRU1BTlRJQ19BVFRSMTMsIGNvbXBvbmVudHM6IDQsIHR5cGU6IFRZUEVfRkxPQVQzMiB9LFxuICAgICAgICAgICAgICAgIHsgc2VtYW50aWM6IFNFTUFOVElDX0FUVFIxNCwgY29tcG9uZW50czogNCwgdHlwZTogVFlQRV9GTE9BVDMyIH0sXG4gICAgICAgICAgICAgICAgeyBzZW1hbnRpYzogU0VNQU5USUNfQVRUUjE1LCBjb21wb25lbnRzOiA0LCB0eXBlOiBUWVBFX0ZMT0FUMzIgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVmVydGV4Rm9ybWF0Ll9kZWZhdWx0SW5zdGFuY2luZ0Zvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIFZlcnRleEZvcm1hdCdzIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgdXNlZCBvbmx5IGJ5IHZlcnRleCBhdHRyaWJ1dGUgbW9ycGhpbmcgb24gdGhlIFdlYkdMLlxuICAgICAgICBEZWJ1Zy5hc3NlcnQoIXRoaXMuZGV2aWNlLmlzV2ViR1BVLCBgVmVydGV4Rm9ybWF0I3VwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkIG9uIFdlYkdQVSBhbmQgVmVydGV4Rm9ybWF0IGNhbm5vdCBiZSBtb2RpZmllZC5gKTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdGVIYXNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGVzIGhhc2ggdmFsdWVzIGZvciB0aGUgZm9ybWF0IGFsbG93aW5nIGZhc3QgY29tcGFyZSBvZiBiYXRjaGluZyAvIHJlbmRlcmluZyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXZhbHVhdGVIYXNoKCkge1xuICAgICAgICBsZXQgc3RyaW5nRWxlbWVudEJhdGNoO1xuICAgICAgICBjb25zdCBzdHJpbmdFbGVtZW50c0JhdGNoID0gW107XG4gICAgICAgIGxldCBzdHJpbmdFbGVtZW50UmVuZGVyO1xuICAgICAgICBjb25zdCBzdHJpbmdFbGVtZW50c1JlbmRlciA9IFtdO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50c1tpXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHN0cmluZyBkZXNjcmlwdGlvbiBvZiBlYWNoIGVsZW1lbnQgdGhhdCBpcyByZWxldmFudCBmb3IgYmF0Y2hpbmdcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRCYXRjaCA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRCYXRjaCArPSBlbGVtZW50LmRhdGFUeXBlO1xuICAgICAgICAgICAgc3RyaW5nRWxlbWVudEJhdGNoICs9IGVsZW1lbnQubnVtQ29tcG9uZW50cztcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRCYXRjaCArPSBlbGVtZW50Lm5vcm1hbGl6ZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRzQmF0Y2gucHVzaChzdHJpbmdFbGVtZW50QmF0Y2gpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIGVhY2ggZWxlbWVudCB0aGF0IGlzIHJlbGV2YW50IGZvciByZW5kZXJpbmdcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRSZW5kZXIgPSBzdHJpbmdFbGVtZW50QmF0Y2g7XG4gICAgICAgICAgICBzdHJpbmdFbGVtZW50UmVuZGVyICs9IGVsZW1lbnQub2Zmc2V0O1xuICAgICAgICAgICAgc3RyaW5nRWxlbWVudFJlbmRlciArPSBlbGVtZW50LnN0cmlkZTtcbiAgICAgICAgICAgIHN0cmluZ0VsZW1lbnRSZW5kZXIgKz0gZWxlbWVudC5zaXplO1xuICAgICAgICAgICAgc3RyaW5nRWxlbWVudHNSZW5kZXIucHVzaChzdHJpbmdFbGVtZW50UmVuZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNvcnQgYmF0Y2hpbmcgb25lcyBhbHBoYWJldGljYWxseSB0byBtYWtlIHRoZSBoYXNoIG9yZGVyIGluZGVwZW5kZW50XG4gICAgICAgIHN0cmluZ0VsZW1lbnRzQmF0Y2guc29ydCgpO1xuICAgICAgICB0aGlzLmJhdGNoaW5nSGFzaCA9IGhhc2hDb2RlKHN0cmluZ0VsZW1lbnRzQmF0Y2guam9pbigpKTtcblxuICAgICAgICAvLyByZW5kZXJpbmcgaGFzaFxuICAgICAgICB0aGlzLnJlbmRlcmluZ0hhc2hTdHJpbmcgPSBzdHJpbmdFbGVtZW50c1JlbmRlci5qb2luKCdfJyk7XG4gICAgICAgIHRoaXMucmVuZGVyaW5nSGFzaCA9IHN0cmluZ0lkcy5nZXQodGhpcy5yZW5kZXJpbmdIYXNoU3RyaW5nKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFZlcnRleEZvcm1hdCB9O1xuIl0sIm5hbWVzIjpbInN0cmluZ0lkcyIsIlN0cmluZ0lkcyIsIlZlcnRleEZvcm1hdCIsImNvbnN0cnVjdG9yIiwiZ3JhcGhpY3NEZXZpY2UiLCJkZXNjcmlwdGlvbiIsInZlcnRleENvdW50IiwiZGV2aWNlIiwiX2VsZW1lbnRzIiwiaGFzVXYwIiwiaGFzVXYxIiwiaGFzQ29sb3IiLCJoYXNUYW5nZW50cyIsInZlcnRpY2VzQnl0ZVNpemUiLCJpbnRlcmxlYXZlZCIsInVuZGVmaW5lZCIsImluc3RhbmNpbmciLCJzaXplIiwicmVkdWNlIiwidG90YWwiLCJkZXNjIiwiTWF0aCIsImNlaWwiLCJjb21wb25lbnRzIiwidHlwZWRBcnJheVR5cGVzQnl0ZVNpemUiLCJ0eXBlIiwib2Zmc2V0IiwiZWxlbWVudFNpemUiLCJpIiwibGVuIiwibGVuZ3RoIiwiX2VsZW1lbnREZXNjJG5vcm1hbGl6IiwiZWxlbWVudERlc2MiLCJEZWJ1ZyIsImFzc2VydCIsImlzV2ViR1BVIiwiaW5jbHVkZXMiLCJzZW1hbnRpYyIsInZlcnRleFR5cGVzTmFtZXMiLCJtYXRoIiwicm91bmRVcCIsImVsZW1lbnQiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJzdHJpZGUiLCJkYXRhVHlwZSIsIm51bUNvbXBvbmVudHMiLCJub3JtYWxpemUiLCJwdXNoIiwiU0VNQU5USUNfVEVYQ09PUkQwIiwiU0VNQU5USUNfVEVYQ09PUkQxIiwiU0VNQU5USUNfQ09MT1IiLCJTRU1BTlRJQ19UQU5HRU5UIiwiX2V2YWx1YXRlSGFzaCIsImVsZW1lbnRzIiwiZ2V0RGVmYXVsdEluc3RhbmNpbmdGb3JtYXQiLCJfZGVmYXVsdEluc3RhbmNpbmdGb3JtYXQiLCJTRU1BTlRJQ19BVFRSMTIiLCJUWVBFX0ZMT0FUMzIiLCJTRU1BTlRJQ19BVFRSMTMiLCJTRU1BTlRJQ19BVFRSMTQiLCJTRU1BTlRJQ19BVFRSMTUiLCJ1cGRhdGUiLCJzdHJpbmdFbGVtZW50QmF0Y2giLCJzdHJpbmdFbGVtZW50c0JhdGNoIiwic3RyaW5nRWxlbWVudFJlbmRlciIsInN0cmluZ0VsZW1lbnRzUmVuZGVyIiwic29ydCIsImJhdGNoaW5nSGFzaCIsImhhc2hDb2RlIiwiam9pbiIsInJlbmRlcmluZ0hhc2hTdHJpbmciLCJyZW5kZXJpbmdIYXNoIiwiZ2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFXQSxNQUFNQSxTQUFTLEdBQUcsSUFBSUMsU0FBUyxFQUFFLENBQUE7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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
